# AOS vs SOA - intro
Ipotizziamo di avere un'architettura **SIMD**, dove ogni thread lavora sullo stesso set di istruzioni, ma su dati differenti
Ipotizziamo inoltre di avere una serie di **Persone, aventi nome ed età**. 
Idealmente, abbiamo due modi per rappresentare questa informazione: **struct of array e array of struct.**
## Concetti chiave
### Structure of Arrays (SOA)
Salca i dati come una singola struct avente una serie di array:

    struct People{
			char **names;//array di string
			int *ages; //array di interi
		}
		//magari, nome ed età potrebbero essere sottoclassi a parte, per conferire un locking più efficiente?

Accedo all'informazione effettuando `People.names[i]`.
#### Pro
- Se un thread lavorasse solamente con una persona delle N, allora solamente quell'informazione andrebbe caricata in memoria e solamente quella verrà iterata: se ho bisogno dei soli nomi, allora verrà caricato in cache solo quello.
- Per via del punto di sopra, l'utilizzo di questa struttura è migliore in architetture di tipo **SIMD.**
- I dati all'interno della struct sono salvati in maniera **omogenea**
#### Contro
Quando campi differenti devono essere acceduti in un'unica volta, i vantaggi **svaniscono**: Accedere a tutti i dati per uno o un paio di oggetti diventa meno efficiente.

### Array of Struct (AOS)
Si potrebbe pensare invece di salvare i dati come strutture multiple, ognuna delle quali contenenti una serie di campi
		
		struct Person{
			char *name;
			int age;
			//eventuali meccanismi di locking/condition e altro
		}
	
		Person *people;

Accedo all'informazione effettuando `people[i].name`.
#### Pro
- Il codice è strutturato intorno ad un **modello più semplice e diretto**
- I singoli record sono **più facili da accedere**
#### Contro
- Lavorando con solo qualcuno dei dati di un record di grandi dimensioni, l'intero set di strutture deve essere **caricato in memoria**, inclusi i dati irrilevanti.
- L'array di struct **non è omogeneo nei dati**: potrebbero essere presenti all'interno di ogni struct dati che non sono dello stesso tipo.

## Contesto multithreaded: SIMD
Ipotizziamo di avere una serie di thread, ognuno dei quali effettua le stesse operazioni in parallelo, ma su dati differenti (SIMD). 
Per semplicità, al momento ipotizziamo di avere un dispositivo dotato di  unico processore (in modo tale da ipotizzare di avere anche una sola cache L1/L2.)

    struct cell{
		 
    }

		
    

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNDgyNjAwMTldfQ==
-->