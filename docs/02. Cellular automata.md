# Automi cellulari
## Definizione
Sono modelli di computazione parallela **discreti nello spazio e nel tempo**, utilizzati per modellare e simulare sistemi complessi.  
Essi possono essere descritti come una **matrice di punti**, nel quale ogni punto viene infuenzato da una cella vicina. Tali punti, difatti, tra di loro dando luogo ad un comportamento complesso.
Possiamo avere due tipi di vicinato:
- **vicinato di Von Neumann**![](http://127.0.0.1:63161/paste-dad68bae49d0ff7510c12375c193bf1e81a040e9.jpg)
-   **vicinato di Moore:** ![](http://127.0.0.1:63161/paste-a7f6749bfef904a72a1e4fb8eeabd6c3f6b0ce4a.jpg)
Entrambi i vicinati si basano sull'utilizzo di un **raggio**. esso può essere 1 o più grande.
## Come funzionano
Al tempo t = 0 le celle sono in uno stato arbitrario che ne definisce la **condizione iniziale** del sistema
L'automa cellulare evolve cambiando gli stati delle celle **applicando simultaneamente ad ogni cella ** la stessa funzione di transizione, così che la sua evoluzione sia determinata da interazioni locali tra il loro vicinato.
Una volta applicata ad ogni cella la funzione di transizione, si dice che è stato effettuato uno **step di transizione**. t verrà incrementato di 1.
Verrà effettuato un numero di step definito in precedenza.
La dinamica emerge come una conseguenza delle applicazioni simultanee della funzione di transizione su ogni cella.

Ogni cella può essere considerata come **un automa, avente un proprio stato**.

## Implementazione
### Concetti generici
Il problema sta nel fatto che per ogni cella, ho bisogno di conoscere (e che rimanga immutato!) lo stato delle celle vicine alla cella con la quale sto lavorando. **Utilizzo pertanto due matrici: una in lettura e una in scrittura.**  

-   I valori attuali sono salvati nella matrice di lettura (o principale)
-   I valori nuovi sono salvati nella matrice di scrittura (o di supporto)

Al termine dello step di transizione, la matrice di scrittura diventa quella di lettura, e quella di lettura la uso per salvare il nuovo valore senza crearne una nuova! **(effettuo uno swap.)**

### Scheletro (seriale)

    #define v(r,c) ((r)*nCols+(c))
    #define nRows 20
    #define nCols 20
    
    int *readM = new int[nRows * nCols]
    int *writeM = new int[nRows * nCols]
    
    int main(){
	    init();
	    for(int step = 0; step < nStep; step++){
			   print(step); //stampo le matrici
			   transfunc(); //applico le funzioni di transizione
			   swap();//swappo
	    }
	    print(nStep);
	    delete[] readM;
	    delete[] writeM;
    }
    
    void init(){
	    //contiene informazioni sullo stato iniziale dell'automa
    }
    
    void transfunc(){
	    for(int i = 0; i< nRows; i++){
		    for(int j = 0; j< nCols; j++){
			    transfuncCell(i,j)
		    }
	    }
	  }
	  
	  //esploro il vicinato della cella i,j
    void transFuncCell(int i, int j){
      //parametri da considerare
	    for(int di = -1; di<2; di++){
		    for(int dj = -1; dj < 2; dj++){
		       //in base al valore delle celle v(i+di, j+dj), modifico i parametri
		    }
	    }
	    //in base ai parametri, modifico la cella
	    //writeM[v(i,j)] = ...;
    }
    
    //scambio i puntatori! 
    void swap(){
	    int *p = readM;
	    readM = writeM;
	    writeM = p;
    }

NOTA: puoi aumentare il raggio facilmente, impostando un valore più grande delle variabili **di e dj**. Grazie all'aritmetica modulare funzionerà sempre! (**non impostarlo, però, più grande di NROWS o NCOLS: non avrebbe senso in quanto andrei a rileggere le stesse celle più volte!**)


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTYyODYyODkyOV19
-->